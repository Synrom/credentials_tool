from dataclasses import dataclass, asdict
from abc import ABC, abstractmethod
import hashlib
import base64
import re
import os
from typing import Iterable

from credentials_tool.abstract_classes import AbstractFormat, AbstractDatabase
from credentials_tool.errors import InterpreterNotFoundError, InterpreterFormatError


@dataclass
class CredentialHolder():
    """
    This class represents the data of one credential instance of the CredentialFormat.
    It also implements methods for hashing.
    """

    email: str
    password: str = ""

    def generate_salt(self):
        """ This function generates a 32-Byte long salt """
        return os.urandom(32)

    def get_hashed_password(self, salt: bytes):
        """
        This calculates and returns the hash of the password of the credential instance represented by this object.

        salt: bytes
            The salt for calculating the hash.
        """

        hashed_pwd = hashlib.pbkdf2_hmac("sha256", self.password.encode("utf-8"), salt, 100000, dklen=128)
        b64_hashed_pwd = base64.b64encode(hashed_pwd).decode("utf-8")

        return b64_hashed_pwd

    def as_tuple_with_hashed_password(self):
        """
        This method generates and returns a tuple containing (email, hashed password, used salt for hashing)
        of the credential instance represented by this object.
        """

        raw_salt = self.generate_salt()
        hashed_pwd = self.get_hashed_password(raw_salt)
        salt = base64.b64encode(raw_salt).decode("utf-8")

        return (self.email, hashed_pwd, salt)


class AbstractItemInterpreterCredential(ABC):
    """
    This class represents an abstract item interpreter for CredentialFormat.
    An item is an string containing exactly one credential instance.
    """

    @abstractmethod
    def check_item(self, item: str) -> bool:
        """
        This method checks wether the format of this item interpreter fits the given item and returns a bool correspondingly.

        item: str
            The item, that will be checked
        """
        pass

    @abstractmethod
    def interpret_item(self, item: str) -> CredentialHolder:
        """
        This method interprets and returns one item.

        item: str
            The item, that will be interpreted
        """
        pass


class ItemInterpreterPasswordMail(AbstractItemInterpreterCredential):
    """
    This ItemInterpreter has the item format "<password>:<email>"
    """

    def __init__(self, email_regex: str):
        self.email_regex = re.compile(email_regex)  # will be specified by CredentialFormat

    def check_item(self, item: str) -> bool:

        item_splited = item.split(":")

        if len(item_splited) < 2:  # there must be at least one ":"
            return False

        # since password can contain ":"s, only check the last element
        if self.email_regex.match(item_splited[-1]):
            return True

        return False

    def interpret_item(self, item: str) -> CredentialHolder:

        item_splited = item.split(":")

        if len(item_splited) < 2:
            raise InterpreterFormatError(item+" is not in the right format <password>:<email>")

        # this is handled in this way since password can contain ":"s
        password = ":".join(item_splited[:-1])
        mail = item_splited[-1]

        return CredentialHolder(email=mail, password=password)


class ItemInterpreterMailPassword(AbstractItemInterpreterCredential):
    """
    This ItemInterpreter has the item format "<mail>:<password>"
    """

    def __init__(self, email_regex: str):  # will be specified by CredentialFormat
        self.email_regex = re.compile(email_regex)

    def check_item(self, item: str) -> bool:

        item_splited = item.split(":")

        if len(item_splited) < 2:  # there must be at least one ":"
            return False

        if self.email_regex.match(item_splited[0]):
            return True

        return False

    def interpret_item(self, item: str) -> CredentialHolder:

        item_splited = item.split(":")

        if len(item_splited) < 2:
            raise InterpreterFormatError(item+" is not in the right format <email>:<password>")

        # this is handled in this way since password can contain ":"s
        mail = item_splited[0]
        password = ":".join(item_splited[1:])

        return CredentialHolder(email=mail, password=password)


class CredentialFormat(AbstractFormat):
    """
    The credential format represented by this class is either stored in <email>:<password> or <password>:<email> items.
    This Format will store credentials in a database in the (email varchar(320), password varchar(172), salt varchar(44)) format:
    - password will be a base64 encoded 128-Byte long pkcs5 kdf2 hmac with sha256, 100000 iterations and a salt
    - salt will be the salt used to generate password and is a base64 encoded 32-Byte salt generated by os.urandom(32)
    The tablename is "credentials_email_and_password".
    This way of storing the credentials slows the performance down significantly, but it is very secure.
    """

    def table_name(self):
        return "credentials_email_and_password"

    def table_columns(self):
        return ("email", "password", "salt")

    def table_types(self):
        return ("varchar(320)", "varchar(172)", "varchar(44)")

    def __init__(self, email_regex: str = r"(^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$)"):

        self.item_interpreters = [ItemInterpreterMailPassword(email_regex), ItemInterpreterPasswordMail(email_regex)]
        self.table_columns_for_search = ("email",)
        self.table_salt_position = 2
        self.table_password_position = 1

    def read_data_from_file(self, filename: str) -> list[CredentialHolder]:

        f = open(filename, "r")

        # this function is needed to still be able to use the item functionalities without having to go over the whole file content
        def readlines() -> Iterable:

            for line in f.readlines():

                if line[-1] == "\n":
                    yield line[:-1]

                else:
                    yield line

        interpreter = self.establish_interpreter_for_itemlist(readlines())

        f.seek(0)

        credentials = []

        for item in readlines():

            credentials.append(interpreter.interpret_item(item))

        f.close()

        return credentials

    def read_data_from_itemlist(self, itemlist: list[str]) -> list[CredentialHolder]:

        interpreter = self.establish_interpreter_for_itemlist(itemlist)

        credentials = []

        for item in itemlist:

            credentials.append(interpreter.interpret_item(item))

        return credentials

    def add_data_to_database(self, database: AbstractDatabase, credentials: list[CredentialHolder]) -> None:

        for credential in credentials:

            database.insert(self.table_name(), credential.as_tuple_with_hashed_password())

    def match_data_with_database(self, database: AbstractDatabase, credentials: list[CredentialHolder]) -> list:

        matches = []

        for credential in credentials:

            search = {}
            credential_dict = asdict(credential)  # dataclasses can be converted to dict

            # constructing a {column_name: value, ...} dict for the database match
            # self.table_columns_for_search ignores password and salt
            for column in self.table_columns_for_search:
                search.update({column: credential_dict[column]})

            matches_of_credential = database.match(self.table_name(), search, return_columns=self.table_columns())

            for match_of_credential in matches_of_credential:

                # if we have a match, we calculate the hash of the password and match that with the database data

                raw_salt = base64.b64decode(match_of_credential[self.table_salt_position])

                if credential.get_hashed_password(raw_salt) == match_of_credential[self.table_password_position]:
                    matches.append(credential)

        return matches

    def add_table_to_database(self, database: AbstractDatabase) -> None:
        database.create_table_if_non_existent(self.table_name(), dict(zip(self.table_columns(), self.table_types())))

    def establish_interpreter_for_itemlist(self, itemlist: Iterable) -> AbstractItemInterpreterCredential:
        """
        This method establishes and returns an item interpreter for a list of items.

        itemlist: Iterable
            list of items for which an item interpreter will be established
        """

        # we go over all items until we find one, where exactly one interpreter works.
        # we do that because one could use its email adress also as a password.
        # then we need to iterate until we find a credential, where email and password distinguish in format

        valid_interpreters = self.item_interpreters.copy()

        for item in itemlist:

            for interpreter in valid_interpreters:

                if not interpreter.check_item(item):
                    valid_interpreters.remove(interpreter)

            if len(valid_interpreters) == 0:
                break

            if len(valid_interpreters) == 1:
                interpreter = valid_interpreters[0]
                return interpreter

        raise InterpreterNotFoundError("No valid interpreter was found")
